(ns perforate.core
  (:require [criterium.core :as crit]))


(defn universal-reducer
  "A function that can be used to reduce any function output."
  [a b]
  (let [a (if (nil? a) 0 a)
        b (if (nil? b) 0 b)]
    (+ (.hashCode a) (.hashCode b))))

(defn benchmark
  "First argument is a doc string or otherwise human readable name to use in
   reporting. The rest of the arguments are key/value pairs, of which the
   following are used:

      :setup  - Specifies a function to call before every test. Its return
                value will be applied to the test-case spawn function.
      :cases  - A vector of benchmark-case maps. These are easily generated by
                the benchmark-case function."
  [doc-string & opts]
  (with-meta (apply hash-map opts) {:doc doc-string
                                    :perforate/benchmark true}))

(defn benchmark-case
  "Generates a benchmark-case map, suitable for use in the :cases key
   of a benchmark map. The test-spawn-fn argument should be a function
   that accepts as many arguments as the corresponding bench-test
   setup function returns in its return vector. The return value of a
   test-spawn-fn should be either a function or a vector containing
   two functions. If it is a function, that function will be the
   function timed during the benchmark. If it is a vector of two
   functions, the first will be the timed function in the benchmark,
   while the second will be called after the benchmark (for any
   cleanup needed)."
  [name test-spawn-fn]
  (with-meta {:name name
              :test-spawn test-spawn-fn}
    {:perforate/benchmark-case true}))

(defmacro bench-fn
  "Convenience macro to generate a benchmark-case spawn function when there is
   no processing required. These two are equivalent:

     * (benchmark-case \"name\" (fn [a1 a2 a3] (fn [] ...)))
     * (benchmark-case \"name\" (bench-fn [a1 a2 a3] ...)

   where the actions of the function are elided."
  [arg-list body]
  `(fn ~arg-list [(fn [] ~body)]))

(defn benchmark-function
  "Benchmark the given function, quick or not."
  [func quick?]
  (if quick?
    (crit/quick-benchmark (func) :reduce-with universal-reducer)
    (crit/benchmark (func) :reduce-with universal-reducer)))

#_(defn summarize-benchmark-results
  "Given a map returned from a criterium benchmark run, print out a nice
   summary."
  [bench-results]
  
  )

(defn run-benchmark
  "Given a benchmark map, returns a map of the variants to their criterium
   benchmark results.

   Options:

       :quick  - Pass true to run a faster, less accurate test."
  [{:keys [setup cases cleanup]} & {:keys [quick]}]
  (let [setup-return (when setup (setup))
        results (doall
                 (into {}
                       (for [{:keys [name test-spawn]} cases]
                         (let [[test-fn & cleanup-fn]
                               (apply test-spawn setup-return)
                               bench-result (benchmark-function test-fn quick)]
                           (when cleanup-fn
                             (apply (first cleanup-fn) setup-return))
                           ;; Finally generate the benchmark result we stored.
                           [name bench-result]))))]
    (when cleanup (apply cleanup setup-return))
    results))

(defn run-benchmarks
  "Given a list of namespaces, runs all the benchmarks they contain."
  [& namespaces]
  (doseq [ns namespaces]
    (let [benchmarks (filter #(:perforate/benchmark (meta %))
                             (map deref (vals (ns-interns (the-ns ns)))))]
      (doseq [benchmark benchmarks]
        (println "Benchmark: " (:doc (meta benchmark)))
        (println "----------")
        (let [benchmark-results (run-benchmark benchmark)]
          (doseq [[case-name case-results] benchmark-results]
            (println "Benchmark Case:" case-name)
            (crit/report-result case-results))))))
  (println ""))
